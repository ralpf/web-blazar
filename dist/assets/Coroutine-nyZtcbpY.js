import{a as n}from"./index-CT3mzoxI.js";import{Time as t}from"./Time-DJp_3Awj.js";const e=class _Coroutine{static start(t){n.Defined(t);const e=null==this.runningSet;e&&(this.runningSet=new Set),this.runningSet.add(new Routine(t)),e&&this.update()}static waitSeconds(n){const t=performance.now()+1e3*n;return new WaitToken(()=>performance.now()>=t)}static waitCondition(n){return new WaitToken(n)}static waitFrames(n){let t=n;return new WaitToken(()=>--t<=0)}};e.update=()=>{if(t.update(),!e.runningSet||0===e.runningSet.size)return void requestAnimationFrame(e.update);const n=[];for(const t of e.runningSet){if(null!=t.token){if(!t.token.isDone)continue;t.token=void 0}const e=t.gen.next();e.value instanceof WaitToken&&!1===e.value.isDone?t.token=e.value:e.done&&n.push(t)}n.forEach(n=>e.runningSet.delete(n)),requestAnimationFrame(e.update)};let i=e;class WaitToken{get isDone(){return this._pred()}constructor(n){this._pred=n}}class Routine{constructor(n){this.gen=n}}export{i as Coroutine,WaitToken};
